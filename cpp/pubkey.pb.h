// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pubkey.proto

#ifndef PROTOBUF_pubkey_2eproto__INCLUDED
#define PROTOBUF_pubkey_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
namespace zsearch {
class ASAtom;
class ASAtomDefaultTypeInternal;
extern ASAtomDefaultTypeInternal _ASAtom_default_instance_;
class CryptographicKey;
class CryptographicKeyDefaultTypeInternal;
extern CryptographicKeyDefaultTypeInternal _CryptographicKey_default_instance_;
class DSACryptographicKey;
class DSACryptographicKeyDefaultTypeInternal;
extern DSACryptographicKeyDefaultTypeInternal _DSACryptographicKey_default_instance_;
class ECCCryptographicKey;
class ECCCryptographicKeyDefaultTypeInternal;
extern ECCCryptographicKeyDefaultTypeInternal _ECCCryptographicKey_default_instance_;
class Metadatum;
class MetadatumDefaultTypeInternal;
extern MetadatumDefaultTypeInternal _Metadatum_default_instance_;
class RSACryptographicKey;
class RSACryptographicKeyDefaultTypeInternal;
extern RSACryptographicKeyDefaultTypeInternal _RSACryptographicKey_default_instance_;
class UserdataAtom;
class UserdataAtomDefaultTypeInternal;
extern UserdataAtomDefaultTypeInternal _UserdataAtom_default_instance_;
}  // namespace zsearch

namespace zsearch {

namespace protobuf_pubkey_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_pubkey_2eproto

enum CryptographicKey_KeyType {
  CryptographicKey_KeyType_RESERVED = 0,
  CryptographicKey_KeyType_UNKNOWN = 1,
  CryptographicKey_KeyType_RSA = 2,
  CryptographicKey_KeyType_DSA = 3,
  CryptographicKey_KeyType_ECC = 4,
  CryptographicKey_KeyType_CryptographicKey_KeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CryptographicKey_KeyType_CryptographicKey_KeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CryptographicKey_KeyType_IsValid(int value);
const CryptographicKey_KeyType CryptographicKey_KeyType_KeyType_MIN = CryptographicKey_KeyType_RESERVED;
const CryptographicKey_KeyType CryptographicKey_KeyType_KeyType_MAX = CryptographicKey_KeyType_ECC;
const int CryptographicKey_KeyType_KeyType_ARRAYSIZE = CryptographicKey_KeyType_KeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CryptographicKey_KeyType_descriptor();
inline const ::std::string& CryptographicKey_KeyType_Name(CryptographicKey_KeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CryptographicKey_KeyType_descriptor(), value);
}
inline bool CryptographicKey_KeyType_Parse(
    const ::std::string& name, CryptographicKey_KeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CryptographicKey_KeyType>(
    CryptographicKey_KeyType_descriptor(), name, value);
}
// ===================================================================

class RSACryptographicKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zsearch.RSACryptographicKey) */ {
 public:
  RSACryptographicKey();
  virtual ~RSACryptographicKey();

  RSACryptographicKey(const RSACryptographicKey& from);

  inline RSACryptographicKey& operator=(const RSACryptographicKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSACryptographicKey& default_instance();

  static inline const RSACryptographicKey* internal_default_instance() {
    return reinterpret_cast<const RSACryptographicKey*>(
               &_RSACryptographicKey_default_instance_);
  }

  void Swap(RSACryptographicKey* other);

  // implements Message ----------------------------------------------

  inline RSACryptographicKey* New() const PROTOBUF_FINAL { return New(NULL); }

  RSACryptographicKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSACryptographicKey& from);
  void MergeFrom(const RSACryptographicKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSACryptographicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes modulus = 1;
  void clear_modulus();
  static const int kModulusFieldNumber = 1;
  const ::std::string& modulus() const;
  void set_modulus(const ::std::string& value);
  #if LANG_CXX11
  void set_modulus(::std::string&& value);
  #endif
  void set_modulus(const char* value);
  void set_modulus(const void* value, size_t size);
  ::std::string* mutable_modulus();
  ::std::string* release_modulus();
  void set_allocated_modulus(::std::string* modulus);

  // bytes exponent = 2;
  void clear_exponent();
  static const int kExponentFieldNumber = 2;
  const ::std::string& exponent() const;
  void set_exponent(const ::std::string& value);
  #if LANG_CXX11
  void set_exponent(::std::string&& value);
  #endif
  void set_exponent(const char* value);
  void set_exponent(const void* value, size_t size);
  ::std::string* mutable_exponent();
  ::std::string* release_exponent();
  void set_allocated_exponent(::std::string* exponent);

  // bytes p = 3;
  void clear_p();
  static const int kPFieldNumber = 3;
  const ::std::string& p() const;
  void set_p(const ::std::string& value);
  #if LANG_CXX11
  void set_p(::std::string&& value);
  #endif
  void set_p(const char* value);
  void set_p(const void* value, size_t size);
  ::std::string* mutable_p();
  ::std::string* release_p();
  void set_allocated_p(::std::string* p);

  // bytes q = 4;
  void clear_q();
  static const int kQFieldNumber = 4;
  const ::std::string& q() const;
  void set_q(const ::std::string& value);
  #if LANG_CXX11
  void set_q(::std::string&& value);
  #endif
  void set_q(const char* value);
  void set_q(const void* value, size_t size);
  ::std::string* mutable_q();
  ::std::string* release_q();
  void set_allocated_q(::std::string* q);

  // @@protoc_insertion_point(class_scope:zsearch.RSACryptographicKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr modulus_;
  ::google::protobuf::internal::ArenaStringPtr exponent_;
  ::google::protobuf::internal::ArenaStringPtr p_;
  ::google::protobuf::internal::ArenaStringPtr q_;
  mutable int _cached_size_;
  friend struct  protobuf_pubkey_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DSACryptographicKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zsearch.DSACryptographicKey) */ {
 public:
  DSACryptographicKey();
  virtual ~DSACryptographicKey();

  DSACryptographicKey(const DSACryptographicKey& from);

  inline DSACryptographicKey& operator=(const DSACryptographicKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DSACryptographicKey& default_instance();

  static inline const DSACryptographicKey* internal_default_instance() {
    return reinterpret_cast<const DSACryptographicKey*>(
               &_DSACryptographicKey_default_instance_);
  }

  void Swap(DSACryptographicKey* other);

  // implements Message ----------------------------------------------

  inline DSACryptographicKey* New() const PROTOBUF_FINAL { return New(NULL); }

  DSACryptographicKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DSACryptographicKey& from);
  void MergeFrom(const DSACryptographicKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DSACryptographicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes p = 1;
  void clear_p();
  static const int kPFieldNumber = 1;
  const ::std::string& p() const;
  void set_p(const ::std::string& value);
  #if LANG_CXX11
  void set_p(::std::string&& value);
  #endif
  void set_p(const char* value);
  void set_p(const void* value, size_t size);
  ::std::string* mutable_p();
  ::std::string* release_p();
  void set_allocated_p(::std::string* p);

  // bytes q = 2;
  void clear_q();
  static const int kQFieldNumber = 2;
  const ::std::string& q() const;
  void set_q(const ::std::string& value);
  #if LANG_CXX11
  void set_q(::std::string&& value);
  #endif
  void set_q(const char* value);
  void set_q(const void* value, size_t size);
  ::std::string* mutable_q();
  ::std::string* release_q();
  void set_allocated_q(::std::string* q);

  // bytes g = 3;
  void clear_g();
  static const int kGFieldNumber = 3;
  const ::std::string& g() const;
  void set_g(const ::std::string& value);
  #if LANG_CXX11
  void set_g(::std::string&& value);
  #endif
  void set_g(const char* value);
  void set_g(const void* value, size_t size);
  ::std::string* mutable_g();
  ::std::string* release_g();
  void set_allocated_g(::std::string* g);

  // bytes y = 4;
  void clear_y();
  static const int kYFieldNumber = 4;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  #if LANG_CXX11
  void set_y(::std::string&& value);
  #endif
  void set_y(const char* value);
  void set_y(const void* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // bytes x = 5;
  void clear_x();
  static const int kXFieldNumber = 5;
  const ::std::string& x() const;
  void set_x(const ::std::string& value);
  #if LANG_CXX11
  void set_x(::std::string&& value);
  #endif
  void set_x(const char* value);
  void set_x(const void* value, size_t size);
  ::std::string* mutable_x();
  ::std::string* release_x();
  void set_allocated_x(::std::string* x);

  // @@protoc_insertion_point(class_scope:zsearch.DSACryptographicKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr p_;
  ::google::protobuf::internal::ArenaStringPtr q_;
  ::google::protobuf::internal::ArenaStringPtr g_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  ::google::protobuf::internal::ArenaStringPtr x_;
  mutable int _cached_size_;
  friend struct  protobuf_pubkey_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ECCCryptographicKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zsearch.ECCCryptographicKey) */ {
 public:
  ECCCryptographicKey();
  virtual ~ECCCryptographicKey();

  ECCCryptographicKey(const ECCCryptographicKey& from);

  inline ECCCryptographicKey& operator=(const ECCCryptographicKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ECCCryptographicKey& default_instance();

  static inline const ECCCryptographicKey* internal_default_instance() {
    return reinterpret_cast<const ECCCryptographicKey*>(
               &_ECCCryptographicKey_default_instance_);
  }

  void Swap(ECCCryptographicKey* other);

  // implements Message ----------------------------------------------

  inline ECCCryptographicKey* New() const PROTOBUF_FINAL { return New(NULL); }

  ECCCryptographicKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ECCCryptographicKey& from);
  void MergeFrom(const ECCCryptographicKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ECCCryptographicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes x = 2;
  void clear_x();
  static const int kXFieldNumber = 2;
  const ::std::string& x() const;
  void set_x(const ::std::string& value);
  #if LANG_CXX11
  void set_x(::std::string&& value);
  #endif
  void set_x(const char* value);
  void set_x(const void* value, size_t size);
  ::std::string* mutable_x();
  ::std::string* release_x();
  void set_allocated_x(::std::string* x);

  // bytes y = 3;
  void clear_y();
  static const int kYFieldNumber = 3;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  #if LANG_CXX11
  void set_y(::std::string&& value);
  #endif
  void set_y(const char* value);
  void set_y(const void* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // bytes private = 4;
  void clear_private_();
  static const int kPrivateFieldNumber = 4;
  const ::std::string& private_() const;
  void set_private_(const ::std::string& value);
  #if LANG_CXX11
  void set_private_(::std::string&& value);
  #endif
  void set_private_(const char* value);
  void set_private_(const void* value, size_t size);
  ::std::string* mutable_private_();
  ::std::string* release_private_();
  void set_allocated_private_(::std::string* private_);

  // uint32 curve = 1;
  void clear_curve();
  static const int kCurveFieldNumber = 1;
  ::google::protobuf::uint32 curve() const;
  void set_curve(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zsearch.ECCCryptographicKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr x_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  ::google::protobuf::internal::ArenaStringPtr private__;
  ::google::protobuf::uint32 curve_;
  mutable int _cached_size_;
  friend struct  protobuf_pubkey_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CryptographicKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zsearch.CryptographicKey) */ {
 public:
  CryptographicKey();
  virtual ~CryptographicKey();

  CryptographicKey(const CryptographicKey& from);

  inline CryptographicKey& operator=(const CryptographicKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CryptographicKey& default_instance();

  enum KeyOneofCase {
    kRsa = 2,
    kDsa = 3,
    kEcc = 4,
    KEY_ONEOF_NOT_SET = 0,
  };

  static inline const CryptographicKey* internal_default_instance() {
    return reinterpret_cast<const CryptographicKey*>(
               &_CryptographicKey_default_instance_);
  }

  void Swap(CryptographicKey* other);

  // implements Message ----------------------------------------------

  inline CryptographicKey* New() const PROTOBUF_FINAL { return New(NULL); }

  CryptographicKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CryptographicKey& from);
  void MergeFrom(const CryptographicKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CryptographicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CryptographicKey_KeyType KeyType;
  static const KeyType RESERVED =
    CryptographicKey_KeyType_RESERVED;
  static const KeyType UNKNOWN =
    CryptographicKey_KeyType_UNKNOWN;
  static const KeyType RSA =
    CryptographicKey_KeyType_RSA;
  static const KeyType DSA =
    CryptographicKey_KeyType_DSA;
  static const KeyType ECC =
    CryptographicKey_KeyType_ECC;
  static inline bool KeyType_IsValid(int value) {
    return CryptographicKey_KeyType_IsValid(value);
  }
  static const KeyType KeyType_MIN =
    CryptographicKey_KeyType_KeyType_MIN;
  static const KeyType KeyType_MAX =
    CryptographicKey_KeyType_KeyType_MAX;
  static const int KeyType_ARRAYSIZE =
    CryptographicKey_KeyType_KeyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  KeyType_descriptor() {
    return CryptographicKey_KeyType_descriptor();
  }
  static inline const ::std::string& KeyType_Name(KeyType value) {
    return CryptographicKey_KeyType_Name(value);
  }
  static inline bool KeyType_Parse(const ::std::string& name,
      KeyType* value) {
    return CryptographicKey_KeyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .zsearch.CryptographicKey.KeyType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::zsearch::CryptographicKey_KeyType type() const;
  void set_type(::zsearch::CryptographicKey_KeyType value);

  // bool broken = 5;
  void clear_broken();
  static const int kBrokenFieldNumber = 5;
  bool broken() const;
  void set_broken(bool value);

  // bool common = 6;
  void clear_common();
  static const int kCommonFieldNumber = 6;
  bool common() const;
  void set_common(bool value);

  // bool debian = 7;
  void clear_debian();
  static const int kDebianFieldNumber = 7;
  bool debian() const;
  void set_debian(bool value);

  // .zsearch.RSACryptographicKey rsa = 2;
  bool has_rsa() const;
  void clear_rsa();
  static const int kRsaFieldNumber = 2;
  const ::zsearch::RSACryptographicKey& rsa() const;
  ::zsearch::RSACryptographicKey* mutable_rsa();
  ::zsearch::RSACryptographicKey* release_rsa();
  void set_allocated_rsa(::zsearch::RSACryptographicKey* rsa);

  // .zsearch.DSACryptographicKey dsa = 3;
  bool has_dsa() const;
  void clear_dsa();
  static const int kDsaFieldNumber = 3;
  const ::zsearch::DSACryptographicKey& dsa() const;
  ::zsearch::DSACryptographicKey* mutable_dsa();
  ::zsearch::DSACryptographicKey* release_dsa();
  void set_allocated_dsa(::zsearch::DSACryptographicKey* dsa);

  // .zsearch.ECCCryptographicKey ecc = 4;
  bool has_ecc() const;
  void clear_ecc();
  static const int kEccFieldNumber = 4;
  const ::zsearch::ECCCryptographicKey& ecc() const;
  ::zsearch::ECCCryptographicKey* mutable_ecc();
  ::zsearch::ECCCryptographicKey* release_ecc();
  void set_allocated_ecc(::zsearch::ECCCryptographicKey* ecc);

  KeyOneofCase key_oneof_case() const;
  // @@protoc_insertion_point(class_scope:zsearch.CryptographicKey)
 private:
  void set_has_rsa();
  void set_has_dsa();
  void set_has_ecc();

  inline bool has_key_oneof() const;
  void clear_key_oneof();
  inline void clear_has_key_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  bool broken_;
  bool common_;
  bool debian_;
  union KeyOneofUnion {
    KeyOneofUnion() {}
    ::zsearch::RSACryptographicKey* rsa_;
    ::zsearch::DSACryptographicKey* dsa_;
    ::zsearch::ECCCryptographicKey* ecc_;
  } key_oneof_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_pubkey_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RSACryptographicKey

// bytes modulus = 1;
inline void RSACryptographicKey::clear_modulus() {
  modulus_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSACryptographicKey::modulus() const {
  // @@protoc_insertion_point(field_get:zsearch.RSACryptographicKey.modulus)
  return modulus_.GetNoArena();
}
inline void RSACryptographicKey::set_modulus(const ::std::string& value) {
  
  modulus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.RSACryptographicKey.modulus)
}
#if LANG_CXX11
inline void RSACryptographicKey::set_modulus(::std::string&& value) {
  
  modulus_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.RSACryptographicKey.modulus)
}
#endif
inline void RSACryptographicKey::set_modulus(const char* value) {
  
  modulus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.RSACryptographicKey.modulus)
}
inline void RSACryptographicKey::set_modulus(const void* value, size_t size) {
  
  modulus_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.RSACryptographicKey.modulus)
}
inline ::std::string* RSACryptographicKey::mutable_modulus() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.RSACryptographicKey.modulus)
  return modulus_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSACryptographicKey::release_modulus() {
  // @@protoc_insertion_point(field_release:zsearch.RSACryptographicKey.modulus)
  
  return modulus_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSACryptographicKey::set_allocated_modulus(::std::string* modulus) {
  if (modulus != NULL) {
    
  } else {
    
  }
  modulus_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modulus);
  // @@protoc_insertion_point(field_set_allocated:zsearch.RSACryptographicKey.modulus)
}

// bytes exponent = 2;
inline void RSACryptographicKey::clear_exponent() {
  exponent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSACryptographicKey::exponent() const {
  // @@protoc_insertion_point(field_get:zsearch.RSACryptographicKey.exponent)
  return exponent_.GetNoArena();
}
inline void RSACryptographicKey::set_exponent(const ::std::string& value) {
  
  exponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.RSACryptographicKey.exponent)
}
#if LANG_CXX11
inline void RSACryptographicKey::set_exponent(::std::string&& value) {
  
  exponent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.RSACryptographicKey.exponent)
}
#endif
inline void RSACryptographicKey::set_exponent(const char* value) {
  
  exponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.RSACryptographicKey.exponent)
}
inline void RSACryptographicKey::set_exponent(const void* value, size_t size) {
  
  exponent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.RSACryptographicKey.exponent)
}
inline ::std::string* RSACryptographicKey::mutable_exponent() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.RSACryptographicKey.exponent)
  return exponent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSACryptographicKey::release_exponent() {
  // @@protoc_insertion_point(field_release:zsearch.RSACryptographicKey.exponent)
  
  return exponent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSACryptographicKey::set_allocated_exponent(::std::string* exponent) {
  if (exponent != NULL) {
    
  } else {
    
  }
  exponent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), exponent);
  // @@protoc_insertion_point(field_set_allocated:zsearch.RSACryptographicKey.exponent)
}

// bytes p = 3;
inline void RSACryptographicKey::clear_p() {
  p_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSACryptographicKey::p() const {
  // @@protoc_insertion_point(field_get:zsearch.RSACryptographicKey.p)
  return p_.GetNoArena();
}
inline void RSACryptographicKey::set_p(const ::std::string& value) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.RSACryptographicKey.p)
}
#if LANG_CXX11
inline void RSACryptographicKey::set_p(::std::string&& value) {
  
  p_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.RSACryptographicKey.p)
}
#endif
inline void RSACryptographicKey::set_p(const char* value) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.RSACryptographicKey.p)
}
inline void RSACryptographicKey::set_p(const void* value, size_t size) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.RSACryptographicKey.p)
}
inline ::std::string* RSACryptographicKey::mutable_p() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.RSACryptographicKey.p)
  return p_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSACryptographicKey::release_p() {
  // @@protoc_insertion_point(field_release:zsearch.RSACryptographicKey.p)
  
  return p_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSACryptographicKey::set_allocated_p(::std::string* p) {
  if (p != NULL) {
    
  } else {
    
  }
  p_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), p);
  // @@protoc_insertion_point(field_set_allocated:zsearch.RSACryptographicKey.p)
}

// bytes q = 4;
inline void RSACryptographicKey::clear_q() {
  q_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSACryptographicKey::q() const {
  // @@protoc_insertion_point(field_get:zsearch.RSACryptographicKey.q)
  return q_.GetNoArena();
}
inline void RSACryptographicKey::set_q(const ::std::string& value) {
  
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.RSACryptographicKey.q)
}
#if LANG_CXX11
inline void RSACryptographicKey::set_q(::std::string&& value) {
  
  q_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.RSACryptographicKey.q)
}
#endif
inline void RSACryptographicKey::set_q(const char* value) {
  
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.RSACryptographicKey.q)
}
inline void RSACryptographicKey::set_q(const void* value, size_t size) {
  
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.RSACryptographicKey.q)
}
inline ::std::string* RSACryptographicKey::mutable_q() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.RSACryptographicKey.q)
  return q_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSACryptographicKey::release_q() {
  // @@protoc_insertion_point(field_release:zsearch.RSACryptographicKey.q)
  
  return q_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSACryptographicKey::set_allocated_q(::std::string* q) {
  if (q != NULL) {
    
  } else {
    
  }
  q_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), q);
  // @@protoc_insertion_point(field_set_allocated:zsearch.RSACryptographicKey.q)
}

// -------------------------------------------------------------------

// DSACryptographicKey

// bytes p = 1;
inline void DSACryptographicKey::clear_p() {
  p_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DSACryptographicKey::p() const {
  // @@protoc_insertion_point(field_get:zsearch.DSACryptographicKey.p)
  return p_.GetNoArena();
}
inline void DSACryptographicKey::set_p(const ::std::string& value) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.DSACryptographicKey.p)
}
#if LANG_CXX11
inline void DSACryptographicKey::set_p(::std::string&& value) {
  
  p_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.DSACryptographicKey.p)
}
#endif
inline void DSACryptographicKey::set_p(const char* value) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.DSACryptographicKey.p)
}
inline void DSACryptographicKey::set_p(const void* value, size_t size) {
  
  p_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.DSACryptographicKey.p)
}
inline ::std::string* DSACryptographicKey::mutable_p() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.DSACryptographicKey.p)
  return p_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DSACryptographicKey::release_p() {
  // @@protoc_insertion_point(field_release:zsearch.DSACryptographicKey.p)
  
  return p_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSACryptographicKey::set_allocated_p(::std::string* p) {
  if (p != NULL) {
    
  } else {
    
  }
  p_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), p);
  // @@protoc_insertion_point(field_set_allocated:zsearch.DSACryptographicKey.p)
}

// bytes q = 2;
inline void DSACryptographicKey::clear_q() {
  q_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DSACryptographicKey::q() const {
  // @@protoc_insertion_point(field_get:zsearch.DSACryptographicKey.q)
  return q_.GetNoArena();
}
inline void DSACryptographicKey::set_q(const ::std::string& value) {
  
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.DSACryptographicKey.q)
}
#if LANG_CXX11
inline void DSACryptographicKey::set_q(::std::string&& value) {
  
  q_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.DSACryptographicKey.q)
}
#endif
inline void DSACryptographicKey::set_q(const char* value) {
  
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.DSACryptographicKey.q)
}
inline void DSACryptographicKey::set_q(const void* value, size_t size) {
  
  q_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.DSACryptographicKey.q)
}
inline ::std::string* DSACryptographicKey::mutable_q() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.DSACryptographicKey.q)
  return q_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DSACryptographicKey::release_q() {
  // @@protoc_insertion_point(field_release:zsearch.DSACryptographicKey.q)
  
  return q_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSACryptographicKey::set_allocated_q(::std::string* q) {
  if (q != NULL) {
    
  } else {
    
  }
  q_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), q);
  // @@protoc_insertion_point(field_set_allocated:zsearch.DSACryptographicKey.q)
}

// bytes g = 3;
inline void DSACryptographicKey::clear_g() {
  g_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DSACryptographicKey::g() const {
  // @@protoc_insertion_point(field_get:zsearch.DSACryptographicKey.g)
  return g_.GetNoArena();
}
inline void DSACryptographicKey::set_g(const ::std::string& value) {
  
  g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.DSACryptographicKey.g)
}
#if LANG_CXX11
inline void DSACryptographicKey::set_g(::std::string&& value) {
  
  g_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.DSACryptographicKey.g)
}
#endif
inline void DSACryptographicKey::set_g(const char* value) {
  
  g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.DSACryptographicKey.g)
}
inline void DSACryptographicKey::set_g(const void* value, size_t size) {
  
  g_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.DSACryptographicKey.g)
}
inline ::std::string* DSACryptographicKey::mutable_g() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.DSACryptographicKey.g)
  return g_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DSACryptographicKey::release_g() {
  // @@protoc_insertion_point(field_release:zsearch.DSACryptographicKey.g)
  
  return g_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSACryptographicKey::set_allocated_g(::std::string* g) {
  if (g != NULL) {
    
  } else {
    
  }
  g_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), g);
  // @@protoc_insertion_point(field_set_allocated:zsearch.DSACryptographicKey.g)
}

// bytes y = 4;
inline void DSACryptographicKey::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DSACryptographicKey::y() const {
  // @@protoc_insertion_point(field_get:zsearch.DSACryptographicKey.y)
  return y_.GetNoArena();
}
inline void DSACryptographicKey::set_y(const ::std::string& value) {
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.DSACryptographicKey.y)
}
#if LANG_CXX11
inline void DSACryptographicKey::set_y(::std::string&& value) {
  
  y_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.DSACryptographicKey.y)
}
#endif
inline void DSACryptographicKey::set_y(const char* value) {
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.DSACryptographicKey.y)
}
inline void DSACryptographicKey::set_y(const void* value, size_t size) {
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.DSACryptographicKey.y)
}
inline ::std::string* DSACryptographicKey::mutable_y() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.DSACryptographicKey.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DSACryptographicKey::release_y() {
  // @@protoc_insertion_point(field_release:zsearch.DSACryptographicKey.y)
  
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSACryptographicKey::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    
  } else {
    
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:zsearch.DSACryptographicKey.y)
}

// bytes x = 5;
inline void DSACryptographicKey::clear_x() {
  x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DSACryptographicKey::x() const {
  // @@protoc_insertion_point(field_get:zsearch.DSACryptographicKey.x)
  return x_.GetNoArena();
}
inline void DSACryptographicKey::set_x(const ::std::string& value) {
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.DSACryptographicKey.x)
}
#if LANG_CXX11
inline void DSACryptographicKey::set_x(::std::string&& value) {
  
  x_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.DSACryptographicKey.x)
}
#endif
inline void DSACryptographicKey::set_x(const char* value) {
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.DSACryptographicKey.x)
}
inline void DSACryptographicKey::set_x(const void* value, size_t size) {
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.DSACryptographicKey.x)
}
inline ::std::string* DSACryptographicKey::mutable_x() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.DSACryptographicKey.x)
  return x_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DSACryptographicKey::release_x() {
  // @@protoc_insertion_point(field_release:zsearch.DSACryptographicKey.x)
  
  return x_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DSACryptographicKey::set_allocated_x(::std::string* x) {
  if (x != NULL) {
    
  } else {
    
  }
  x_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:zsearch.DSACryptographicKey.x)
}

// -------------------------------------------------------------------

// ECCCryptographicKey

// uint32 curve = 1;
inline void ECCCryptographicKey::clear_curve() {
  curve_ = 0u;
}
inline ::google::protobuf::uint32 ECCCryptographicKey::curve() const {
  // @@protoc_insertion_point(field_get:zsearch.ECCCryptographicKey.curve)
  return curve_;
}
inline void ECCCryptographicKey::set_curve(::google::protobuf::uint32 value) {
  
  curve_ = value;
  // @@protoc_insertion_point(field_set:zsearch.ECCCryptographicKey.curve)
}

// bytes x = 2;
inline void ECCCryptographicKey::clear_x() {
  x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ECCCryptographicKey::x() const {
  // @@protoc_insertion_point(field_get:zsearch.ECCCryptographicKey.x)
  return x_.GetNoArena();
}
inline void ECCCryptographicKey::set_x(const ::std::string& value) {
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.ECCCryptographicKey.x)
}
#if LANG_CXX11
inline void ECCCryptographicKey::set_x(::std::string&& value) {
  
  x_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.ECCCryptographicKey.x)
}
#endif
inline void ECCCryptographicKey::set_x(const char* value) {
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.ECCCryptographicKey.x)
}
inline void ECCCryptographicKey::set_x(const void* value, size_t size) {
  
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.ECCCryptographicKey.x)
}
inline ::std::string* ECCCryptographicKey::mutable_x() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.ECCCryptographicKey.x)
  return x_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ECCCryptographicKey::release_x() {
  // @@protoc_insertion_point(field_release:zsearch.ECCCryptographicKey.x)
  
  return x_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ECCCryptographicKey::set_allocated_x(::std::string* x) {
  if (x != NULL) {
    
  } else {
    
  }
  x_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:zsearch.ECCCryptographicKey.x)
}

// bytes y = 3;
inline void ECCCryptographicKey::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ECCCryptographicKey::y() const {
  // @@protoc_insertion_point(field_get:zsearch.ECCCryptographicKey.y)
  return y_.GetNoArena();
}
inline void ECCCryptographicKey::set_y(const ::std::string& value) {
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.ECCCryptographicKey.y)
}
#if LANG_CXX11
inline void ECCCryptographicKey::set_y(::std::string&& value) {
  
  y_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.ECCCryptographicKey.y)
}
#endif
inline void ECCCryptographicKey::set_y(const char* value) {
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.ECCCryptographicKey.y)
}
inline void ECCCryptographicKey::set_y(const void* value, size_t size) {
  
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.ECCCryptographicKey.y)
}
inline ::std::string* ECCCryptographicKey::mutable_y() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.ECCCryptographicKey.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ECCCryptographicKey::release_y() {
  // @@protoc_insertion_point(field_release:zsearch.ECCCryptographicKey.y)
  
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ECCCryptographicKey::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    
  } else {
    
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:zsearch.ECCCryptographicKey.y)
}

// bytes private = 4;
inline void ECCCryptographicKey::clear_private_() {
  private__.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ECCCryptographicKey::private_() const {
  // @@protoc_insertion_point(field_get:zsearch.ECCCryptographicKey.private)
  return private__.GetNoArena();
}
inline void ECCCryptographicKey::set_private_(const ::std::string& value) {
  
  private__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.ECCCryptographicKey.private)
}
#if LANG_CXX11
inline void ECCCryptographicKey::set_private_(::std::string&& value) {
  
  private__.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.ECCCryptographicKey.private)
}
#endif
inline void ECCCryptographicKey::set_private_(const char* value) {
  
  private__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.ECCCryptographicKey.private)
}
inline void ECCCryptographicKey::set_private_(const void* value, size_t size) {
  
  private__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.ECCCryptographicKey.private)
}
inline ::std::string* ECCCryptographicKey::mutable_private_() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.ECCCryptographicKey.private)
  return private__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ECCCryptographicKey::release_private_() {
  // @@protoc_insertion_point(field_release:zsearch.ECCCryptographicKey.private)
  
  return private__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ECCCryptographicKey::set_allocated_private_(::std::string* private_) {
  if (private_ != NULL) {
    
  } else {
    
  }
  private__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), private_);
  // @@protoc_insertion_point(field_set_allocated:zsearch.ECCCryptographicKey.private)
}

// -------------------------------------------------------------------

// CryptographicKey

// .zsearch.CryptographicKey.KeyType type = 1;
inline void CryptographicKey::clear_type() {
  type_ = 0;
}
inline ::zsearch::CryptographicKey_KeyType CryptographicKey::type() const {
  // @@protoc_insertion_point(field_get:zsearch.CryptographicKey.type)
  return static_cast< ::zsearch::CryptographicKey_KeyType >(type_);
}
inline void CryptographicKey::set_type(::zsearch::CryptographicKey_KeyType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:zsearch.CryptographicKey.type)
}

// .zsearch.RSACryptographicKey rsa = 2;
inline bool CryptographicKey::has_rsa() const {
  return key_oneof_case() == kRsa;
}
inline void CryptographicKey::set_has_rsa() {
  _oneof_case_[0] = kRsa;
}
inline void CryptographicKey::clear_rsa() {
  if (has_rsa()) {
    delete key_oneof_.rsa_;
    clear_has_key_oneof();
  }
}
inline  const ::zsearch::RSACryptographicKey& CryptographicKey::rsa() const {
  // @@protoc_insertion_point(field_get:zsearch.CryptographicKey.rsa)
  return has_rsa()
      ? *key_oneof_.rsa_
      : ::zsearch::RSACryptographicKey::default_instance();
}
inline ::zsearch::RSACryptographicKey* CryptographicKey::mutable_rsa() {
  if (!has_rsa()) {
    clear_key_oneof();
    set_has_rsa();
    key_oneof_.rsa_ = new ::zsearch::RSACryptographicKey;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.CryptographicKey.rsa)
  return key_oneof_.rsa_;
}
inline ::zsearch::RSACryptographicKey* CryptographicKey::release_rsa() {
  // @@protoc_insertion_point(field_release:zsearch.CryptographicKey.rsa)
  if (has_rsa()) {
    clear_has_key_oneof();
    ::zsearch::RSACryptographicKey* temp = key_oneof_.rsa_;
    key_oneof_.rsa_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CryptographicKey::set_allocated_rsa(::zsearch::RSACryptographicKey* rsa) {
  clear_key_oneof();
  if (rsa) {
    set_has_rsa();
    key_oneof_.rsa_ = rsa;
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.CryptographicKey.rsa)
}

// .zsearch.DSACryptographicKey dsa = 3;
inline bool CryptographicKey::has_dsa() const {
  return key_oneof_case() == kDsa;
}
inline void CryptographicKey::set_has_dsa() {
  _oneof_case_[0] = kDsa;
}
inline void CryptographicKey::clear_dsa() {
  if (has_dsa()) {
    delete key_oneof_.dsa_;
    clear_has_key_oneof();
  }
}
inline  const ::zsearch::DSACryptographicKey& CryptographicKey::dsa() const {
  // @@protoc_insertion_point(field_get:zsearch.CryptographicKey.dsa)
  return has_dsa()
      ? *key_oneof_.dsa_
      : ::zsearch::DSACryptographicKey::default_instance();
}
inline ::zsearch::DSACryptographicKey* CryptographicKey::mutable_dsa() {
  if (!has_dsa()) {
    clear_key_oneof();
    set_has_dsa();
    key_oneof_.dsa_ = new ::zsearch::DSACryptographicKey;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.CryptographicKey.dsa)
  return key_oneof_.dsa_;
}
inline ::zsearch::DSACryptographicKey* CryptographicKey::release_dsa() {
  // @@protoc_insertion_point(field_release:zsearch.CryptographicKey.dsa)
  if (has_dsa()) {
    clear_has_key_oneof();
    ::zsearch::DSACryptographicKey* temp = key_oneof_.dsa_;
    key_oneof_.dsa_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CryptographicKey::set_allocated_dsa(::zsearch::DSACryptographicKey* dsa) {
  clear_key_oneof();
  if (dsa) {
    set_has_dsa();
    key_oneof_.dsa_ = dsa;
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.CryptographicKey.dsa)
}

// .zsearch.ECCCryptographicKey ecc = 4;
inline bool CryptographicKey::has_ecc() const {
  return key_oneof_case() == kEcc;
}
inline void CryptographicKey::set_has_ecc() {
  _oneof_case_[0] = kEcc;
}
inline void CryptographicKey::clear_ecc() {
  if (has_ecc()) {
    delete key_oneof_.ecc_;
    clear_has_key_oneof();
  }
}
inline  const ::zsearch::ECCCryptographicKey& CryptographicKey::ecc() const {
  // @@protoc_insertion_point(field_get:zsearch.CryptographicKey.ecc)
  return has_ecc()
      ? *key_oneof_.ecc_
      : ::zsearch::ECCCryptographicKey::default_instance();
}
inline ::zsearch::ECCCryptographicKey* CryptographicKey::mutable_ecc() {
  if (!has_ecc()) {
    clear_key_oneof();
    set_has_ecc();
    key_oneof_.ecc_ = new ::zsearch::ECCCryptographicKey;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.CryptographicKey.ecc)
  return key_oneof_.ecc_;
}
inline ::zsearch::ECCCryptographicKey* CryptographicKey::release_ecc() {
  // @@protoc_insertion_point(field_release:zsearch.CryptographicKey.ecc)
  if (has_ecc()) {
    clear_has_key_oneof();
    ::zsearch::ECCCryptographicKey* temp = key_oneof_.ecc_;
    key_oneof_.ecc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void CryptographicKey::set_allocated_ecc(::zsearch::ECCCryptographicKey* ecc) {
  clear_key_oneof();
  if (ecc) {
    set_has_ecc();
    key_oneof_.ecc_ = ecc;
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.CryptographicKey.ecc)
}

// bool broken = 5;
inline void CryptographicKey::clear_broken() {
  broken_ = false;
}
inline bool CryptographicKey::broken() const {
  // @@protoc_insertion_point(field_get:zsearch.CryptographicKey.broken)
  return broken_;
}
inline void CryptographicKey::set_broken(bool value) {
  
  broken_ = value;
  // @@protoc_insertion_point(field_set:zsearch.CryptographicKey.broken)
}

// bool common = 6;
inline void CryptographicKey::clear_common() {
  common_ = false;
}
inline bool CryptographicKey::common() const {
  // @@protoc_insertion_point(field_get:zsearch.CryptographicKey.common)
  return common_;
}
inline void CryptographicKey::set_common(bool value) {
  
  common_ = value;
  // @@protoc_insertion_point(field_set:zsearch.CryptographicKey.common)
}

// bool debian = 7;
inline void CryptographicKey::clear_debian() {
  debian_ = false;
}
inline bool CryptographicKey::debian() const {
  // @@protoc_insertion_point(field_get:zsearch.CryptographicKey.debian)
  return debian_;
}
inline void CryptographicKey::set_debian(bool value) {
  
  debian_ = value;
  // @@protoc_insertion_point(field_set:zsearch.CryptographicKey.debian)
}

inline bool CryptographicKey::has_key_oneof() const {
  return key_oneof_case() != KEY_ONEOF_NOT_SET;
}
inline void CryptographicKey::clear_has_key_oneof() {
  _oneof_case_[0] = KEY_ONEOF_NOT_SET;
}
inline CryptographicKey::KeyOneofCase CryptographicKey::key_oneof_case() const {
  return CryptographicKey::KeyOneofCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace zsearch

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zsearch::CryptographicKey_KeyType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zsearch::CryptographicKey_KeyType>() {
  return ::zsearch::CryptographicKey_KeyType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pubkey_2eproto__INCLUDED
