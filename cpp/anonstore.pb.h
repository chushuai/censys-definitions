// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anonstore.proto

#ifndef PROTOBUF_anonstore_2eproto__INCLUDED
#define PROTOBUF_anonstore_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "pubkey.pb.h"
#include "ct.pb.h"
#include "certificate.pb.h"
// @@protoc_insertion_point(includes)
namespace zsearch {
class ASAtom;
class ASAtomDefaultTypeInternal;
extern ASAtomDefaultTypeInternal _ASAtom_default_instance_;
class AnonymousDelta;
class AnonymousDeltaDefaultTypeInternal;
extern AnonymousDeltaDefaultTypeInternal _AnonymousDelta_default_instance_;
class AnonymousRecord;
class AnonymousRecordDefaultTypeInternal;
extern AnonymousRecordDefaultTypeInternal _AnonymousRecord_default_instance_;
class CTServerStatus;
class CTServerStatusDefaultTypeInternal;
extern CTServerStatusDefaultTypeInternal _CTServerStatus_default_instance_;
class CTStatus;
class CTStatusDefaultTypeInternal;
extern CTStatusDefaultTypeInternal _CTStatus_default_instance_;
class Certificate;
class CertificateDefaultTypeInternal;
extern CertificateDefaultTypeInternal _Certificate_default_instance_;
class CertificateAudit;
class CertificateAuditDefaultTypeInternal;
extern CertificateAuditDefaultTypeInternal _CertificateAudit_default_instance_;
class CertificateRevocation;
class CertificateRevocationDefaultTypeInternal;
extern CertificateRevocationDefaultTypeInternal _CertificateRevocation_default_instance_;
class CertificateValidation;
class CertificateValidationDefaultTypeInternal;
extern CertificateValidationDefaultTypeInternal _CertificateValidation_default_instance_;
class CryptographicKey;
class CryptographicKeyDefaultTypeInternal;
extern CryptographicKeyDefaultTypeInternal _CryptographicKey_default_instance_;
class DSACryptographicKey;
class DSACryptographicKeyDefaultTypeInternal;
extern DSACryptographicKeyDefaultTypeInternal _DSACryptographicKey_default_instance_;
class ECCCryptographicKey;
class ECCCryptographicKeyDefaultTypeInternal;
extern ECCCryptographicKeyDefaultTypeInternal _ECCCryptographicKey_default_instance_;
class ExternalCertificate;
class ExternalCertificateDefaultTypeInternal;
extern ExternalCertificateDefaultTypeInternal _ExternalCertificate_default_instance_;
class Metadatum;
class MetadatumDefaultTypeInternal;
extern MetadatumDefaultTypeInternal _Metadatum_default_instance_;
class MozillaSalesForceStatus;
class MozillaSalesForceStatusDefaultTypeInternal;
extern MozillaSalesForceStatusDefaultTypeInternal _MozillaSalesForceStatus_default_instance_;
class Path;
class PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class RSACryptographicKey;
class RSACryptographicKeyDefaultTypeInternal;
extern RSACryptographicKeyDefaultTypeInternal _RSACryptographicKey_default_instance_;
class RootStoreStatus;
class RootStoreStatusDefaultTypeInternal;
extern RootStoreStatusDefaultTypeInternal _RootStoreStatus_default_instance_;
class SCT;
class SCTDefaultTypeInternal;
extern SCTDefaultTypeInternal _SCT_default_instance_;
class UserdataAtom;
class UserdataAtomDefaultTypeInternal;
extern UserdataAtomDefaultTypeInternal _UserdataAtom_default_instance_;
}  // namespace zsearch

namespace zsearch {

namespace protobuf_anonstore_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_anonstore_2eproto

enum AnonymousDelta_DeltaType {
  AnonymousDelta_DeltaType_DT_RESERVED = 0,
  AnonymousDelta_DeltaType_DT_UPDATE = 1,
  AnonymousDelta_DeltaType_DT_DELETE = 2,
  AnonymousDelta_DeltaType_AnonymousDelta_DeltaType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AnonymousDelta_DeltaType_AnonymousDelta_DeltaType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AnonymousDelta_DeltaType_IsValid(int value);
const AnonymousDelta_DeltaType AnonymousDelta_DeltaType_DeltaType_MIN = AnonymousDelta_DeltaType_DT_RESERVED;
const AnonymousDelta_DeltaType AnonymousDelta_DeltaType_DeltaType_MAX = AnonymousDelta_DeltaType_DT_DELETE;
const int AnonymousDelta_DeltaType_DeltaType_ARRAYSIZE = AnonymousDelta_DeltaType_DeltaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AnonymousDelta_DeltaType_descriptor();
inline const ::std::string& AnonymousDelta_DeltaType_Name(AnonymousDelta_DeltaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AnonymousDelta_DeltaType_descriptor(), value);
}
inline bool AnonymousDelta_DeltaType_Parse(
    const ::std::string& name, AnonymousDelta_DeltaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnonymousDelta_DeltaType>(
    AnonymousDelta_DeltaType_descriptor(), name, value);
}
enum AnonymousDelta_DeltaScope {
  AnonymousDelta_DeltaScope_SCOPE_RESERVED = 0,
  AnonymousDelta_DeltaScope_SCOPE_NO_CHANGE = 1,
  AnonymousDelta_DeltaScope_SCOPE_NEW = 2,
  AnonymousDelta_DeltaScope_SCOPE_UPDATE = 3,
  AnonymousDelta_DeltaScope_AnonymousDelta_DeltaScope_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AnonymousDelta_DeltaScope_AnonymousDelta_DeltaScope_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AnonymousDelta_DeltaScope_IsValid(int value);
const AnonymousDelta_DeltaScope AnonymousDelta_DeltaScope_DeltaScope_MIN = AnonymousDelta_DeltaScope_SCOPE_RESERVED;
const AnonymousDelta_DeltaScope AnonymousDelta_DeltaScope_DeltaScope_MAX = AnonymousDelta_DeltaScope_SCOPE_UPDATE;
const int AnonymousDelta_DeltaScope_DeltaScope_ARRAYSIZE = AnonymousDelta_DeltaScope_DeltaScope_MAX + 1;

const ::google::protobuf::EnumDescriptor* AnonymousDelta_DeltaScope_descriptor();
inline const ::std::string& AnonymousDelta_DeltaScope_Name(AnonymousDelta_DeltaScope value) {
  return ::google::protobuf::internal::NameOfEnum(
    AnonymousDelta_DeltaScope_descriptor(), value);
}
inline bool AnonymousDelta_DeltaScope_Parse(
    const ::std::string& name, AnonymousDelta_DeltaScope* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnonymousDelta_DeltaScope>(
    AnonymousDelta_DeltaScope_descriptor(), name, value);
}
// ===================================================================

class AnonymousRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zsearch.AnonymousRecord) */ {
 public:
  AnonymousRecord();
  virtual ~AnonymousRecord();

  AnonymousRecord(const AnonymousRecord& from);

  inline AnonymousRecord& operator=(const AnonymousRecord& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnonymousRecord& default_instance();

  enum OneofDataCase {
    kData = 6,
    kRawData = 7,
    kCertificate = 8,
    kKey = 9,
    kAs = 10,
    ONEOF_DATA_NOT_SET = 0,
  };

  static inline const AnonymousRecord* internal_default_instance() {
    return reinterpret_cast<const AnonymousRecord*>(
               &_AnonymousRecord_default_instance_);
  }

  void Swap(AnonymousRecord* other);

  // implements Message ----------------------------------------------

  inline AnonymousRecord* New() const PROTOBUF_FINAL { return New(NULL); }

  AnonymousRecord* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnonymousRecord& from);
  void MergeFrom(const AnonymousRecord& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnonymousRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zsearch.Metadatum metadata = 14;
  int metadata_size() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 14;
  const ::zsearch::Metadatum& metadata(int index) const;
  ::zsearch::Metadatum* mutable_metadata(int index);
  ::zsearch::Metadatum* add_metadata();
  ::google::protobuf::RepeatedPtrField< ::zsearch::Metadatum >*
      mutable_metadata();
  const ::google::protobuf::RepeatedPtrField< ::zsearch::Metadatum >&
      metadata() const;

  // repeated string tags = 15;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 15;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // bytes sha256fp = 1;
  void clear_sha256fp();
  static const int kSha256FpFieldNumber = 1;
  const ::std::string& sha256fp() const;
  void set_sha256fp(const ::std::string& value);
  #if LANG_CXX11
  void set_sha256fp(::std::string&& value);
  #endif
  void set_sha256fp(const char* value);
  void set_sha256fp(const void* value, size_t size);
  ::std::string* mutable_sha256fp();
  ::std::string* release_sha256fp();
  void set_allocated_sha256fp(::std::string* sha256fp);

  // .zsearch.UserdataAtom userdata = 5;
  bool has_userdata() const;
  void clear_userdata();
  static const int kUserdataFieldNumber = 5;
  const ::zsearch::UserdataAtom& userdata() const;
  ::zsearch::UserdataAtom* mutable_userdata();
  ::zsearch::UserdataAtom* release_userdata();
  void set_allocated_userdata(::zsearch::UserdataAtom* userdata);

  // sfixed64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // uint32 scan_id = 3;
  void clear_scan_id();
  static const int kScanIdFieldNumber = 3;
  ::google::protobuf::uint32 scan_id() const;
  void set_scan_id(::google::protobuf::uint32 value);

  // bool exported = 4 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_exported();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kExportedFieldNumber = 4;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool exported() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_exported(bool value);

  // fixed32 updated_at = 16;
  void clear_updated_at();
  static const int kUpdatedAtFieldNumber = 16;
  ::google::protobuf::uint32 updated_at() const;
  void set_updated_at(::google::protobuf::uint32 value);

  // fixed32 added_at = 17;
  void clear_added_at();
  static const int kAddedAtFieldNumber = 17;
  ::google::protobuf::uint32 added_at() const;
  void set_added_at(::google::protobuf::uint32 value);

  // string data = 6;
  private:
  bool has_data() const;
  public:
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // bytes raw_data = 7;
  private:
  bool has_raw_data() const;
  public:
  void clear_raw_data();
  static const int kRawDataFieldNumber = 7;
  const ::std::string& raw_data() const;
  void set_raw_data(const ::std::string& value);
  #if LANG_CXX11
  void set_raw_data(::std::string&& value);
  #endif
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  ::std::string* mutable_raw_data();
  ::std::string* release_raw_data();
  void set_allocated_raw_data(::std::string* raw_data);

  // .zsearch.Certificate certificate = 8;
  bool has_certificate() const;
  void clear_certificate();
  static const int kCertificateFieldNumber = 8;
  const ::zsearch::Certificate& certificate() const;
  ::zsearch::Certificate* mutable_certificate();
  ::zsearch::Certificate* release_certificate();
  void set_allocated_certificate(::zsearch::Certificate* certificate);

  // .zsearch.CryptographicKey key = 9;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 9;
  const ::zsearch::CryptographicKey& key() const;
  ::zsearch::CryptographicKey* mutable_key();
  ::zsearch::CryptographicKey* release_key();
  void set_allocated_key(::zsearch::CryptographicKey* key);

  // .zsearch.ASAtom as = 10;
  bool has_as() const;
  void clear_as();
  static const int kAsFieldNumber = 10;
  const ::zsearch::ASAtom& as() const;
  ::zsearch::ASAtom* mutable_as();
  ::zsearch::ASAtom* release_as();
  void set_allocated_as(::zsearch::ASAtom* as);

  OneofDataCase oneof_data_case() const;
  // @@protoc_insertion_point(class_scope:zsearch.AnonymousRecord)
 private:
  void set_has_data();
  void set_has_raw_data();
  void set_has_certificate();
  void set_has_key();
  void set_has_as();

  inline bool has_oneof_data() const;
  void clear_oneof_data();
  inline void clear_has_oneof_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::zsearch::Metadatum > metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::internal::ArenaStringPtr sha256fp_;
  ::zsearch::UserdataAtom* userdata_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::uint32 scan_id_;
  bool exported_;
  ::google::protobuf::uint32 updated_at_;
  ::google::protobuf::uint32 added_at_;
  union OneofDataUnion {
    OneofDataUnion() {}
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr raw_data_;
    ::zsearch::Certificate* certificate_;
    ::zsearch::CryptographicKey* key_;
    ::zsearch::ASAtom* as_;
  } oneof_data_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_anonstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnonymousDelta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zsearch.AnonymousDelta) */ {
 public:
  AnonymousDelta();
  virtual ~AnonymousDelta();

  AnonymousDelta(const AnonymousDelta& from);

  inline AnonymousDelta& operator=(const AnonymousDelta& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnonymousDelta& default_instance();

  static inline const AnonymousDelta* internal_default_instance() {
    return reinterpret_cast<const AnonymousDelta*>(
               &_AnonymousDelta_default_instance_);
  }

  void Swap(AnonymousDelta* other);

  // implements Message ----------------------------------------------

  inline AnonymousDelta* New() const PROTOBUF_FINAL { return New(NULL); }

  AnonymousDelta* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnonymousDelta& from);
  void MergeFrom(const AnonymousDelta& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnonymousDelta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AnonymousDelta_DeltaType DeltaType;
  static const DeltaType DT_RESERVED =
    AnonymousDelta_DeltaType_DT_RESERVED;
  static const DeltaType DT_UPDATE =
    AnonymousDelta_DeltaType_DT_UPDATE;
  static const DeltaType DT_DELETE =
    AnonymousDelta_DeltaType_DT_DELETE;
  static inline bool DeltaType_IsValid(int value) {
    return AnonymousDelta_DeltaType_IsValid(value);
  }
  static const DeltaType DeltaType_MIN =
    AnonymousDelta_DeltaType_DeltaType_MIN;
  static const DeltaType DeltaType_MAX =
    AnonymousDelta_DeltaType_DeltaType_MAX;
  static const int DeltaType_ARRAYSIZE =
    AnonymousDelta_DeltaType_DeltaType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeltaType_descriptor() {
    return AnonymousDelta_DeltaType_descriptor();
  }
  static inline const ::std::string& DeltaType_Name(DeltaType value) {
    return AnonymousDelta_DeltaType_Name(value);
  }
  static inline bool DeltaType_Parse(const ::std::string& name,
      DeltaType* value) {
    return AnonymousDelta_DeltaType_Parse(name, value);
  }

  typedef AnonymousDelta_DeltaScope DeltaScope;
  static const DeltaScope SCOPE_RESERVED =
    AnonymousDelta_DeltaScope_SCOPE_RESERVED;
  static const DeltaScope SCOPE_NO_CHANGE =
    AnonymousDelta_DeltaScope_SCOPE_NO_CHANGE;
  static const DeltaScope SCOPE_NEW =
    AnonymousDelta_DeltaScope_SCOPE_NEW;
  static const DeltaScope SCOPE_UPDATE =
    AnonymousDelta_DeltaScope_SCOPE_UPDATE;
  static inline bool DeltaScope_IsValid(int value) {
    return AnonymousDelta_DeltaScope_IsValid(value);
  }
  static const DeltaScope DeltaScope_MIN =
    AnonymousDelta_DeltaScope_DeltaScope_MIN;
  static const DeltaScope DeltaScope_MAX =
    AnonymousDelta_DeltaScope_DeltaScope_MAX;
  static const int DeltaScope_ARRAYSIZE =
    AnonymousDelta_DeltaScope_DeltaScope_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeltaScope_descriptor() {
    return AnonymousDelta_DeltaScope_descriptor();
  }
  static inline const ::std::string& DeltaScope_Name(DeltaScope value) {
    return AnonymousDelta_DeltaScope_Name(value);
  }
  static inline bool DeltaScope_Parse(const ::std::string& name,
      DeltaScope* value) {
    return AnonymousDelta_DeltaScope_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .zsearch.AnonymousRecord record = 3;
  bool has_record() const;
  void clear_record();
  static const int kRecordFieldNumber = 3;
  const ::zsearch::AnonymousRecord& record() const;
  ::zsearch::AnonymousRecord* mutable_record();
  ::zsearch::AnonymousRecord* release_record();
  void set_allocated_record(::zsearch::AnonymousRecord* record);

  // .zsearch.AnonymousDelta.DeltaType delta_type = 1;
  void clear_delta_type();
  static const int kDeltaTypeFieldNumber = 1;
  ::zsearch::AnonymousDelta_DeltaType delta_type() const;
  void set_delta_type(::zsearch::AnonymousDelta_DeltaType value);

  // .zsearch.AnonymousDelta.DeltaScope delta_scope = 2;
  void clear_delta_scope();
  static const int kDeltaScopeFieldNumber = 2;
  ::zsearch::AnonymousDelta_DeltaScope delta_scope() const;
  void set_delta_scope(::zsearch::AnonymousDelta_DeltaScope value);

  // @@protoc_insertion_point(class_scope:zsearch.AnonymousDelta)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::zsearch::AnonymousRecord* record_;
  int delta_type_;
  int delta_scope_;
  mutable int _cached_size_;
  friend struct  protobuf_anonstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExternalCertificate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:zsearch.ExternalCertificate) */ {
 public:
  ExternalCertificate();
  virtual ~ExternalCertificate();

  ExternalCertificate(const ExternalCertificate& from);

  inline ExternalCertificate& operator=(const ExternalCertificate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalCertificate& default_instance();

  static inline const ExternalCertificate* internal_default_instance() {
    return reinterpret_cast<const ExternalCertificate*>(
               &_ExternalCertificate_default_instance_);
  }

  void Swap(ExternalCertificate* other);

  // implements Message ----------------------------------------------

  inline ExternalCertificate* New() const PROTOBUF_FINAL { return New(NULL); }

  ExternalCertificate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExternalCertificate& from);
  void MergeFrom(const ExternalCertificate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExternalCertificate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tbsHash = 6;
  void clear_tbshash();
  static const int kTbsHashFieldNumber = 6;
  const ::std::string& tbshash() const;
  void set_tbshash(const ::std::string& value);
  #if LANG_CXX11
  void set_tbshash(::std::string&& value);
  #endif
  void set_tbshash(const char* value);
  void set_tbshash(const void* value, size_t size);
  ::std::string* mutable_tbshash();
  ::std::string* release_tbshash();
  void set_allocated_tbshash(::std::string* tbshash);

  // .zsearch.AnonymousRecord anonymous_record = 2;
  bool has_anonymous_record() const;
  void clear_anonymous_record();
  static const int kAnonymousRecordFieldNumber = 2;
  const ::zsearch::AnonymousRecord& anonymous_record() const;
  ::zsearch::AnonymousRecord* mutable_anonymous_record();
  ::zsearch::AnonymousRecord* release_anonymous_record();
  void set_allocated_anonymous_record(::zsearch::AnonymousRecord* anonymous_record);

  // .zsearch.CTServerStatus ct_status = 4;
  bool has_ct_status() const;
  void clear_ct_status();
  static const int kCtStatusFieldNumber = 4;
  const ::zsearch::CTServerStatus& ct_status() const;
  ::zsearch::CTServerStatus* mutable_ct_status();
  ::zsearch::CTServerStatus* release_ct_status();
  void set_allocated_ct_status(::zsearch::CTServerStatus* ct_status);

  // .zsearch.MozillaSalesForceStatus nss_status = 5;
  bool has_nss_status() const;
  void clear_nss_status();
  static const int kNssStatusFieldNumber = 5;
  const ::zsearch::MozillaSalesForceStatus& nss_status() const;
  ::zsearch::MozillaSalesForceStatus* mutable_nss_status();
  ::zsearch::MozillaSalesForceStatus* release_nss_status();
  void set_allocated_nss_status(::zsearch::MozillaSalesForceStatus* nss_status);

  // .zsearch.CertificateSource source = 1;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::zsearch::CertificateSource source() const;
  void set_source(::zsearch::CertificateSource value);

  // .zsearch.CTServer ct_server = 3;
  void clear_ct_server();
  static const int kCtServerFieldNumber = 3;
  ::zsearch::CTServer ct_server() const;
  void set_ct_server(::zsearch::CTServer value);

  // @@protoc_insertion_point(class_scope:zsearch.ExternalCertificate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tbshash_;
  ::zsearch::AnonymousRecord* anonymous_record_;
  ::zsearch::CTServerStatus* ct_status_;
  ::zsearch::MozillaSalesForceStatus* nss_status_;
  int source_;
  int ct_server_;
  mutable int _cached_size_;
  friend struct  protobuf_anonstore_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AnonymousRecord

// bytes sha256fp = 1;
inline void AnonymousRecord::clear_sha256fp() {
  sha256fp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AnonymousRecord::sha256fp() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.sha256fp)
  return sha256fp_.GetNoArena();
}
inline void AnonymousRecord::set_sha256fp(const ::std::string& value) {
  
  sha256fp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.sha256fp)
}
#if LANG_CXX11
inline void AnonymousRecord::set_sha256fp(::std::string&& value) {
  
  sha256fp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.AnonymousRecord.sha256fp)
}
#endif
inline void AnonymousRecord::set_sha256fp(const char* value) {
  
  sha256fp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.AnonymousRecord.sha256fp)
}
inline void AnonymousRecord::set_sha256fp(const void* value, size_t size) {
  
  sha256fp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.AnonymousRecord.sha256fp)
}
inline ::std::string* AnonymousRecord::mutable_sha256fp() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.sha256fp)
  return sha256fp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnonymousRecord::release_sha256fp() {
  // @@protoc_insertion_point(field_release:zsearch.AnonymousRecord.sha256fp)
  
  return sha256fp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnonymousRecord::set_allocated_sha256fp(::std::string* sha256fp) {
  if (sha256fp != NULL) {
    
  } else {
    
  }
  sha256fp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sha256fp);
  // @@protoc_insertion_point(field_set_allocated:zsearch.AnonymousRecord.sha256fp)
}

// sfixed64 timestamp = 2;
inline void AnonymousRecord::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AnonymousRecord::timestamp() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.timestamp)
  return timestamp_;
}
inline void AnonymousRecord::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.timestamp)
}

// uint32 scan_id = 3;
inline void AnonymousRecord::clear_scan_id() {
  scan_id_ = 0u;
}
inline ::google::protobuf::uint32 AnonymousRecord::scan_id() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.scan_id)
  return scan_id_;
}
inline void AnonymousRecord::set_scan_id(::google::protobuf::uint32 value) {
  
  scan_id_ = value;
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.scan_id)
}

// bool exported = 4 [deprecated = true];
inline void AnonymousRecord::clear_exported() {
  exported_ = false;
}
inline bool AnonymousRecord::exported() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.exported)
  return exported_;
}
inline void AnonymousRecord::set_exported(bool value) {
  
  exported_ = value;
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.exported)
}

// .zsearch.UserdataAtom userdata = 5;
inline bool AnonymousRecord::has_userdata() const {
  return this != internal_default_instance() && userdata_ != NULL;
}
inline void AnonymousRecord::clear_userdata() {
  if (GetArenaNoVirtual() == NULL && userdata_ != NULL) delete userdata_;
  userdata_ = NULL;
}
inline const ::zsearch::UserdataAtom& AnonymousRecord::userdata() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.userdata)
  return userdata_ != NULL ? *userdata_
                         : *::zsearch::UserdataAtom::internal_default_instance();
}
inline ::zsearch::UserdataAtom* AnonymousRecord::mutable_userdata() {
  
  if (userdata_ == NULL) {
    userdata_ = new ::zsearch::UserdataAtom;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.userdata)
  return userdata_;
}
inline ::zsearch::UserdataAtom* AnonymousRecord::release_userdata() {
  // @@protoc_insertion_point(field_release:zsearch.AnonymousRecord.userdata)
  
  ::zsearch::UserdataAtom* temp = userdata_;
  userdata_ = NULL;
  return temp;
}
inline void AnonymousRecord::set_allocated_userdata(::zsearch::UserdataAtom* userdata) {
  delete userdata_;
  userdata_ = userdata;
  if (userdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.AnonymousRecord.userdata)
}

// string data = 6;
inline bool AnonymousRecord::has_data() const {
  return oneof_data_case() == kData;
}
inline void AnonymousRecord::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void AnonymousRecord::clear_data() {
  if (has_data()) {
    oneof_data_.data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_oneof_data();
  }
}
inline const ::std::string& AnonymousRecord::data() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.data)
  if (has_data()) {
    return oneof_data_.data_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AnonymousRecord::set_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.data)
  if (!has_data()) {
    clear_oneof_data();
    set_has_data();
    oneof_data_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  oneof_data_.data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.data)
}
#if LANG_CXX11
inline void AnonymousRecord::set_data(::std::string&& value) {
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.data)
  if (!has_data()) {
    clear_oneof_data();
    set_has_data();
    oneof_data_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  oneof_data_.data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.AnonymousRecord.data)
}
#endif
inline void AnonymousRecord::set_data(const char* value) {
  if (!has_data()) {
    clear_oneof_data();
    set_has_data();
    oneof_data_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  oneof_data_.data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.AnonymousRecord.data)
}
inline void AnonymousRecord::set_data(const char* value, size_t size) {
  if (!has_data()) {
    clear_oneof_data();
    set_has_data();
    oneof_data_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  oneof_data_.data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.AnonymousRecord.data)
}
inline ::std::string* AnonymousRecord::mutable_data() {
  if (!has_data()) {
    clear_oneof_data();
    set_has_data();
    oneof_data_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.data)
  return oneof_data_.data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnonymousRecord::release_data() {
  // @@protoc_insertion_point(field_release:zsearch.AnonymousRecord.data)
  if (has_data()) {
    clear_has_oneof_data();
    return oneof_data_.data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AnonymousRecord::set_allocated_data(::std::string* data) {
  if (!has_data()) {
    oneof_data_.data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_oneof_data();
  if (data != NULL) {
    set_has_data();
    oneof_data_.data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        data);
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.AnonymousRecord.data)
}

// bytes raw_data = 7;
inline bool AnonymousRecord::has_raw_data() const {
  return oneof_data_case() == kRawData;
}
inline void AnonymousRecord::set_has_raw_data() {
  _oneof_case_[0] = kRawData;
}
inline void AnonymousRecord::clear_raw_data() {
  if (has_raw_data()) {
    oneof_data_.raw_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_oneof_data();
  }
}
inline const ::std::string& AnonymousRecord::raw_data() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.raw_data)
  if (has_raw_data()) {
    return oneof_data_.raw_data_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AnonymousRecord::set_raw_data(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.raw_data)
  if (!has_raw_data()) {
    clear_oneof_data();
    set_has_raw_data();
    oneof_data_.raw_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  oneof_data_.raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.raw_data)
}
#if LANG_CXX11
inline void AnonymousRecord::set_raw_data(::std::string&& value) {
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.raw_data)
  if (!has_raw_data()) {
    clear_oneof_data();
    set_has_raw_data();
    oneof_data_.raw_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  oneof_data_.raw_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.AnonymousRecord.raw_data)
}
#endif
inline void AnonymousRecord::set_raw_data(const char* value) {
  if (!has_raw_data()) {
    clear_oneof_data();
    set_has_raw_data();
    oneof_data_.raw_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  oneof_data_.raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.AnonymousRecord.raw_data)
}
inline void AnonymousRecord::set_raw_data(const void* value, size_t size) {
  if (!has_raw_data()) {
    clear_oneof_data();
    set_has_raw_data();
    oneof_data_.raw_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  oneof_data_.raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.AnonymousRecord.raw_data)
}
inline ::std::string* AnonymousRecord::mutable_raw_data() {
  if (!has_raw_data()) {
    clear_oneof_data();
    set_has_raw_data();
    oneof_data_.raw_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.raw_data)
  return oneof_data_.raw_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnonymousRecord::release_raw_data() {
  // @@protoc_insertion_point(field_release:zsearch.AnonymousRecord.raw_data)
  if (has_raw_data()) {
    clear_has_oneof_data();
    return oneof_data_.raw_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AnonymousRecord::set_allocated_raw_data(::std::string* raw_data) {
  if (!has_raw_data()) {
    oneof_data_.raw_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_oneof_data();
  if (raw_data != NULL) {
    set_has_raw_data();
    oneof_data_.raw_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        raw_data);
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.AnonymousRecord.raw_data)
}

// .zsearch.Certificate certificate = 8;
inline bool AnonymousRecord::has_certificate() const {
  return oneof_data_case() == kCertificate;
}
inline void AnonymousRecord::set_has_certificate() {
  _oneof_case_[0] = kCertificate;
}
inline void AnonymousRecord::clear_certificate() {
  if (has_certificate()) {
    delete oneof_data_.certificate_;
    clear_has_oneof_data();
  }
}
inline  const ::zsearch::Certificate& AnonymousRecord::certificate() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.certificate)
  return has_certificate()
      ? *oneof_data_.certificate_
      : ::zsearch::Certificate::default_instance();
}
inline ::zsearch::Certificate* AnonymousRecord::mutable_certificate() {
  if (!has_certificate()) {
    clear_oneof_data();
    set_has_certificate();
    oneof_data_.certificate_ = new ::zsearch::Certificate;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.certificate)
  return oneof_data_.certificate_;
}
inline ::zsearch::Certificate* AnonymousRecord::release_certificate() {
  // @@protoc_insertion_point(field_release:zsearch.AnonymousRecord.certificate)
  if (has_certificate()) {
    clear_has_oneof_data();
    ::zsearch::Certificate* temp = oneof_data_.certificate_;
    oneof_data_.certificate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnonymousRecord::set_allocated_certificate(::zsearch::Certificate* certificate) {
  clear_oneof_data();
  if (certificate) {
    set_has_certificate();
    oneof_data_.certificate_ = certificate;
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.AnonymousRecord.certificate)
}

// .zsearch.CryptographicKey key = 9;
inline bool AnonymousRecord::has_key() const {
  return oneof_data_case() == kKey;
}
inline void AnonymousRecord::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void AnonymousRecord::clear_key() {
  if (has_key()) {
    delete oneof_data_.key_;
    clear_has_oneof_data();
  }
}
inline  const ::zsearch::CryptographicKey& AnonymousRecord::key() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.key)
  return has_key()
      ? *oneof_data_.key_
      : ::zsearch::CryptographicKey::default_instance();
}
inline ::zsearch::CryptographicKey* AnonymousRecord::mutable_key() {
  if (!has_key()) {
    clear_oneof_data();
    set_has_key();
    oneof_data_.key_ = new ::zsearch::CryptographicKey;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.key)
  return oneof_data_.key_;
}
inline ::zsearch::CryptographicKey* AnonymousRecord::release_key() {
  // @@protoc_insertion_point(field_release:zsearch.AnonymousRecord.key)
  if (has_key()) {
    clear_has_oneof_data();
    ::zsearch::CryptographicKey* temp = oneof_data_.key_;
    oneof_data_.key_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnonymousRecord::set_allocated_key(::zsearch::CryptographicKey* key) {
  clear_oneof_data();
  if (key) {
    set_has_key();
    oneof_data_.key_ = key;
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.AnonymousRecord.key)
}

// .zsearch.ASAtom as = 10;
inline bool AnonymousRecord::has_as() const {
  return oneof_data_case() == kAs;
}
inline void AnonymousRecord::set_has_as() {
  _oneof_case_[0] = kAs;
}
inline void AnonymousRecord::clear_as() {
  if (has_as()) {
    delete oneof_data_.as_;
    clear_has_oneof_data();
  }
}
inline  const ::zsearch::ASAtom& AnonymousRecord::as() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.as)
  return has_as()
      ? *oneof_data_.as_
      : ::zsearch::ASAtom::default_instance();
}
inline ::zsearch::ASAtom* AnonymousRecord::mutable_as() {
  if (!has_as()) {
    clear_oneof_data();
    set_has_as();
    oneof_data_.as_ = new ::zsearch::ASAtom;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.as)
  return oneof_data_.as_;
}
inline ::zsearch::ASAtom* AnonymousRecord::release_as() {
  // @@protoc_insertion_point(field_release:zsearch.AnonymousRecord.as)
  if (has_as()) {
    clear_has_oneof_data();
    ::zsearch::ASAtom* temp = oneof_data_.as_;
    oneof_data_.as_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AnonymousRecord::set_allocated_as(::zsearch::ASAtom* as) {
  clear_oneof_data();
  if (as) {
    set_has_as();
    oneof_data_.as_ = as;
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.AnonymousRecord.as)
}

// repeated .zsearch.Metadatum metadata = 14;
inline int AnonymousRecord::metadata_size() const {
  return metadata_.size();
}
inline void AnonymousRecord::clear_metadata() {
  metadata_.Clear();
}
inline const ::zsearch::Metadatum& AnonymousRecord::metadata(int index) const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.metadata)
  return metadata_.Get(index);
}
inline ::zsearch::Metadatum* AnonymousRecord::mutable_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.metadata)
  return metadata_.Mutable(index);
}
inline ::zsearch::Metadatum* AnonymousRecord::add_metadata() {
  // @@protoc_insertion_point(field_add:zsearch.AnonymousRecord.metadata)
  return metadata_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::zsearch::Metadatum >*
AnonymousRecord::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_list:zsearch.AnonymousRecord.metadata)
  return &metadata_;
}
inline const ::google::protobuf::RepeatedPtrField< ::zsearch::Metadatum >&
AnonymousRecord::metadata() const {
  // @@protoc_insertion_point(field_list:zsearch.AnonymousRecord.metadata)
  return metadata_;
}

// repeated string tags = 15;
inline int AnonymousRecord::tags_size() const {
  return tags_.size();
}
inline void AnonymousRecord::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& AnonymousRecord::tags(int index) const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.tags)
  return tags_.Get(index);
}
inline ::std::string* AnonymousRecord::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousRecord.tags)
  return tags_.Mutable(index);
}
inline void AnonymousRecord::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.tags)
  tags_.Mutable(index)->assign(value);
}
inline void AnonymousRecord::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:zsearch.AnonymousRecord.tags)
}
inline void AnonymousRecord::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zsearch.AnonymousRecord.tags)
}
inline ::std::string* AnonymousRecord::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:zsearch.AnonymousRecord.tags)
  return tags_.Add();
}
inline void AnonymousRecord::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:zsearch.AnonymousRecord.tags)
}
inline void AnonymousRecord::add_tags(const char* value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:zsearch.AnonymousRecord.tags)
}
inline void AnonymousRecord::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:zsearch.AnonymousRecord.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AnonymousRecord::tags() const {
  // @@protoc_insertion_point(field_list:zsearch.AnonymousRecord.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AnonymousRecord::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:zsearch.AnonymousRecord.tags)
  return &tags_;
}

// fixed32 updated_at = 16;
inline void AnonymousRecord::clear_updated_at() {
  updated_at_ = 0u;
}
inline ::google::protobuf::uint32 AnonymousRecord::updated_at() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.updated_at)
  return updated_at_;
}
inline void AnonymousRecord::set_updated_at(::google::protobuf::uint32 value) {
  
  updated_at_ = value;
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.updated_at)
}

// fixed32 added_at = 17;
inline void AnonymousRecord::clear_added_at() {
  added_at_ = 0u;
}
inline ::google::protobuf::uint32 AnonymousRecord::added_at() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousRecord.added_at)
  return added_at_;
}
inline void AnonymousRecord::set_added_at(::google::protobuf::uint32 value) {
  
  added_at_ = value;
  // @@protoc_insertion_point(field_set:zsearch.AnonymousRecord.added_at)
}

inline bool AnonymousRecord::has_oneof_data() const {
  return oneof_data_case() != ONEOF_DATA_NOT_SET;
}
inline void AnonymousRecord::clear_has_oneof_data() {
  _oneof_case_[0] = ONEOF_DATA_NOT_SET;
}
inline AnonymousRecord::OneofDataCase AnonymousRecord::oneof_data_case() const {
  return AnonymousRecord::OneofDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnonymousDelta

// .zsearch.AnonymousDelta.DeltaType delta_type = 1;
inline void AnonymousDelta::clear_delta_type() {
  delta_type_ = 0;
}
inline ::zsearch::AnonymousDelta_DeltaType AnonymousDelta::delta_type() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousDelta.delta_type)
  return static_cast< ::zsearch::AnonymousDelta_DeltaType >(delta_type_);
}
inline void AnonymousDelta::set_delta_type(::zsearch::AnonymousDelta_DeltaType value) {
  
  delta_type_ = value;
  // @@protoc_insertion_point(field_set:zsearch.AnonymousDelta.delta_type)
}

// .zsearch.AnonymousDelta.DeltaScope delta_scope = 2;
inline void AnonymousDelta::clear_delta_scope() {
  delta_scope_ = 0;
}
inline ::zsearch::AnonymousDelta_DeltaScope AnonymousDelta::delta_scope() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousDelta.delta_scope)
  return static_cast< ::zsearch::AnonymousDelta_DeltaScope >(delta_scope_);
}
inline void AnonymousDelta::set_delta_scope(::zsearch::AnonymousDelta_DeltaScope value) {
  
  delta_scope_ = value;
  // @@protoc_insertion_point(field_set:zsearch.AnonymousDelta.delta_scope)
}

// .zsearch.AnonymousRecord record = 3;
inline bool AnonymousDelta::has_record() const {
  return this != internal_default_instance() && record_ != NULL;
}
inline void AnonymousDelta::clear_record() {
  if (GetArenaNoVirtual() == NULL && record_ != NULL) delete record_;
  record_ = NULL;
}
inline const ::zsearch::AnonymousRecord& AnonymousDelta::record() const {
  // @@protoc_insertion_point(field_get:zsearch.AnonymousDelta.record)
  return record_ != NULL ? *record_
                         : *::zsearch::AnonymousRecord::internal_default_instance();
}
inline ::zsearch::AnonymousRecord* AnonymousDelta::mutable_record() {
  
  if (record_ == NULL) {
    record_ = new ::zsearch::AnonymousRecord;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.AnonymousDelta.record)
  return record_;
}
inline ::zsearch::AnonymousRecord* AnonymousDelta::release_record() {
  // @@protoc_insertion_point(field_release:zsearch.AnonymousDelta.record)
  
  ::zsearch::AnonymousRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void AnonymousDelta::set_allocated_record(::zsearch::AnonymousRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.AnonymousDelta.record)
}

// -------------------------------------------------------------------

// ExternalCertificate

// .zsearch.CertificateSource source = 1;
inline void ExternalCertificate::clear_source() {
  source_ = 0;
}
inline ::zsearch::CertificateSource ExternalCertificate::source() const {
  // @@protoc_insertion_point(field_get:zsearch.ExternalCertificate.source)
  return static_cast< ::zsearch::CertificateSource >(source_);
}
inline void ExternalCertificate::set_source(::zsearch::CertificateSource value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:zsearch.ExternalCertificate.source)
}

// .zsearch.AnonymousRecord anonymous_record = 2;
inline bool ExternalCertificate::has_anonymous_record() const {
  return this != internal_default_instance() && anonymous_record_ != NULL;
}
inline void ExternalCertificate::clear_anonymous_record() {
  if (GetArenaNoVirtual() == NULL && anonymous_record_ != NULL) delete anonymous_record_;
  anonymous_record_ = NULL;
}
inline const ::zsearch::AnonymousRecord& ExternalCertificate::anonymous_record() const {
  // @@protoc_insertion_point(field_get:zsearch.ExternalCertificate.anonymous_record)
  return anonymous_record_ != NULL ? *anonymous_record_
                         : *::zsearch::AnonymousRecord::internal_default_instance();
}
inline ::zsearch::AnonymousRecord* ExternalCertificate::mutable_anonymous_record() {
  
  if (anonymous_record_ == NULL) {
    anonymous_record_ = new ::zsearch::AnonymousRecord;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.ExternalCertificate.anonymous_record)
  return anonymous_record_;
}
inline ::zsearch::AnonymousRecord* ExternalCertificate::release_anonymous_record() {
  // @@protoc_insertion_point(field_release:zsearch.ExternalCertificate.anonymous_record)
  
  ::zsearch::AnonymousRecord* temp = anonymous_record_;
  anonymous_record_ = NULL;
  return temp;
}
inline void ExternalCertificate::set_allocated_anonymous_record(::zsearch::AnonymousRecord* anonymous_record) {
  delete anonymous_record_;
  anonymous_record_ = anonymous_record;
  if (anonymous_record) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.ExternalCertificate.anonymous_record)
}

// .zsearch.CTServer ct_server = 3;
inline void ExternalCertificate::clear_ct_server() {
  ct_server_ = 0;
}
inline ::zsearch::CTServer ExternalCertificate::ct_server() const {
  // @@protoc_insertion_point(field_get:zsearch.ExternalCertificate.ct_server)
  return static_cast< ::zsearch::CTServer >(ct_server_);
}
inline void ExternalCertificate::set_ct_server(::zsearch::CTServer value) {
  
  ct_server_ = value;
  // @@protoc_insertion_point(field_set:zsearch.ExternalCertificate.ct_server)
}

// .zsearch.CTServerStatus ct_status = 4;
inline bool ExternalCertificate::has_ct_status() const {
  return this != internal_default_instance() && ct_status_ != NULL;
}
inline void ExternalCertificate::clear_ct_status() {
  if (GetArenaNoVirtual() == NULL && ct_status_ != NULL) delete ct_status_;
  ct_status_ = NULL;
}
inline const ::zsearch::CTServerStatus& ExternalCertificate::ct_status() const {
  // @@protoc_insertion_point(field_get:zsearch.ExternalCertificate.ct_status)
  return ct_status_ != NULL ? *ct_status_
                         : *::zsearch::CTServerStatus::internal_default_instance();
}
inline ::zsearch::CTServerStatus* ExternalCertificate::mutable_ct_status() {
  
  if (ct_status_ == NULL) {
    ct_status_ = new ::zsearch::CTServerStatus;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.ExternalCertificate.ct_status)
  return ct_status_;
}
inline ::zsearch::CTServerStatus* ExternalCertificate::release_ct_status() {
  // @@protoc_insertion_point(field_release:zsearch.ExternalCertificate.ct_status)
  
  ::zsearch::CTServerStatus* temp = ct_status_;
  ct_status_ = NULL;
  return temp;
}
inline void ExternalCertificate::set_allocated_ct_status(::zsearch::CTServerStatus* ct_status) {
  delete ct_status_;
  ct_status_ = ct_status;
  if (ct_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.ExternalCertificate.ct_status)
}

// .zsearch.MozillaSalesForceStatus nss_status = 5;
inline bool ExternalCertificate::has_nss_status() const {
  return this != internal_default_instance() && nss_status_ != NULL;
}
inline void ExternalCertificate::clear_nss_status() {
  if (GetArenaNoVirtual() == NULL && nss_status_ != NULL) delete nss_status_;
  nss_status_ = NULL;
}
inline const ::zsearch::MozillaSalesForceStatus& ExternalCertificate::nss_status() const {
  // @@protoc_insertion_point(field_get:zsearch.ExternalCertificate.nss_status)
  return nss_status_ != NULL ? *nss_status_
                         : *::zsearch::MozillaSalesForceStatus::internal_default_instance();
}
inline ::zsearch::MozillaSalesForceStatus* ExternalCertificate::mutable_nss_status() {
  
  if (nss_status_ == NULL) {
    nss_status_ = new ::zsearch::MozillaSalesForceStatus;
  }
  // @@protoc_insertion_point(field_mutable:zsearch.ExternalCertificate.nss_status)
  return nss_status_;
}
inline ::zsearch::MozillaSalesForceStatus* ExternalCertificate::release_nss_status() {
  // @@protoc_insertion_point(field_release:zsearch.ExternalCertificate.nss_status)
  
  ::zsearch::MozillaSalesForceStatus* temp = nss_status_;
  nss_status_ = NULL;
  return temp;
}
inline void ExternalCertificate::set_allocated_nss_status(::zsearch::MozillaSalesForceStatus* nss_status) {
  delete nss_status_;
  nss_status_ = nss_status;
  if (nss_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:zsearch.ExternalCertificate.nss_status)
}

// bytes tbsHash = 6;
inline void ExternalCertificate::clear_tbshash() {
  tbshash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExternalCertificate::tbshash() const {
  // @@protoc_insertion_point(field_get:zsearch.ExternalCertificate.tbsHash)
  return tbshash_.GetNoArena();
}
inline void ExternalCertificate::set_tbshash(const ::std::string& value) {
  
  tbshash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:zsearch.ExternalCertificate.tbsHash)
}
#if LANG_CXX11
inline void ExternalCertificate::set_tbshash(::std::string&& value) {
  
  tbshash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:zsearch.ExternalCertificate.tbsHash)
}
#endif
inline void ExternalCertificate::set_tbshash(const char* value) {
  
  tbshash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:zsearch.ExternalCertificate.tbsHash)
}
inline void ExternalCertificate::set_tbshash(const void* value, size_t size) {
  
  tbshash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:zsearch.ExternalCertificate.tbsHash)
}
inline ::std::string* ExternalCertificate::mutable_tbshash() {
  
  // @@protoc_insertion_point(field_mutable:zsearch.ExternalCertificate.tbsHash)
  return tbshash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalCertificate::release_tbshash() {
  // @@protoc_insertion_point(field_release:zsearch.ExternalCertificate.tbsHash)
  
  return tbshash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalCertificate::set_allocated_tbshash(::std::string* tbshash) {
  if (tbshash != NULL) {
    
  } else {
    
  }
  tbshash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tbshash);
  // @@protoc_insertion_point(field_set_allocated:zsearch.ExternalCertificate.tbsHash)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace zsearch

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zsearch::AnonymousDelta_DeltaType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zsearch::AnonymousDelta_DeltaType>() {
  return ::zsearch::AnonymousDelta_DeltaType_descriptor();
}
template <> struct is_proto_enum< ::zsearch::AnonymousDelta_DeltaScope> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zsearch::AnonymousDelta_DeltaScope>() {
  return ::zsearch::AnonymousDelta_DeltaScope_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_anonstore_2eproto__INCLUDED
