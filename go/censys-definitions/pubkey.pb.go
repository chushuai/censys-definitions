// Code generated by protoc-gen-go.
// source: pubkey.proto
// DO NOT EDIT!

package censys_definitions

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type CryptographicKey_KeyType int32

const (
	CryptographicKey_RESERVED CryptographicKey_KeyType = 0
	CryptographicKey_UNKNOWN  CryptographicKey_KeyType = 1
	CryptographicKey_RSA      CryptographicKey_KeyType = 2
	CryptographicKey_DSA      CryptographicKey_KeyType = 3
	CryptographicKey_ECC      CryptographicKey_KeyType = 4
)

var CryptographicKey_KeyType_name = map[int32]string{
	0: "RESERVED",
	1: "UNKNOWN",
	2: "RSA",
	3: "DSA",
	4: "ECC",
}
var CryptographicKey_KeyType_value = map[string]int32{
	"RESERVED": 0,
	"UNKNOWN":  1,
	"RSA":      2,
	"DSA":      3,
	"ECC":      4,
}

func (x CryptographicKey_KeyType) String() string {
	return proto.EnumName(CryptographicKey_KeyType_name, int32(x))
}
func (CryptographicKey_KeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor6, []int{3, 0} }

type RSACryptographicKey struct {
	Modulus  []byte `protobuf:"bytes,1,opt,name=modulus,proto3" json:"modulus,omitempty"`
	Exponent []byte `protobuf:"bytes,2,opt,name=exponent,proto3" json:"exponent,omitempty"`
	P        []byte `protobuf:"bytes,3,opt,name=p,proto3" json:"p,omitempty"`
	Q        []byte `protobuf:"bytes,4,opt,name=q,proto3" json:"q,omitempty"`
}

func (m *RSACryptographicKey) Reset()                    { *m = RSACryptographicKey{} }
func (m *RSACryptographicKey) String() string            { return proto.CompactTextString(m) }
func (*RSACryptographicKey) ProtoMessage()               {}
func (*RSACryptographicKey) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{0} }

type DSACryptographicKey struct {
	P []byte `protobuf:"bytes,1,opt,name=p,proto3" json:"p,omitempty"`
	Q []byte `protobuf:"bytes,2,opt,name=q,proto3" json:"q,omitempty"`
	G []byte `protobuf:"bytes,3,opt,name=g,proto3" json:"g,omitempty"`
	Y []byte `protobuf:"bytes,4,opt,name=y,proto3" json:"y,omitempty"`
	X []byte `protobuf:"bytes,5,opt,name=x,proto3" json:"x,omitempty"`
}

func (m *DSACryptographicKey) Reset()                    { *m = DSACryptographicKey{} }
func (m *DSACryptographicKey) String() string            { return proto.CompactTextString(m) }
func (*DSACryptographicKey) ProtoMessage()               {}
func (*DSACryptographicKey) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{1} }

type ECCCryptographicKey struct {
	Curve   uint32 `protobuf:"varint,1,opt,name=curve" json:"curve,omitempty"`
	X       []byte `protobuf:"bytes,2,opt,name=x,proto3" json:"x,omitempty"`
	Y       []byte `protobuf:"bytes,3,opt,name=y,proto3" json:"y,omitempty"`
	Private []byte `protobuf:"bytes,4,opt,name=private,proto3" json:"private,omitempty"`
}

func (m *ECCCryptographicKey) Reset()                    { *m = ECCCryptographicKey{} }
func (m *ECCCryptographicKey) String() string            { return proto.CompactTextString(m) }
func (*ECCCryptographicKey) ProtoMessage()               {}
func (*ECCCryptographicKey) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{2} }

type CryptographicKey struct {
	Type CryptographicKey_KeyType `protobuf:"varint,1,opt,name=type,enum=zsearch.CryptographicKey_KeyType" json:"type,omitempty"`
	// Types that are valid to be assigned to KeyOneof:
	//	*CryptographicKey_Rsa
	//	*CryptographicKey_Dsa
	//	*CryptographicKey_Ecc
	KeyOneof isCryptographicKey_KeyOneof `protobuf_oneof:"key_oneof"`
	Broken   bool                        `protobuf:"varint,5,opt,name=broken" json:"broken,omitempty"`
	Common   bool                        `protobuf:"varint,6,opt,name=common" json:"common,omitempty"`
	Debian   bool                        `protobuf:"varint,7,opt,name=debian" json:"debian,omitempty"`
}

func (m *CryptographicKey) Reset()                    { *m = CryptographicKey{} }
func (m *CryptographicKey) String() string            { return proto.CompactTextString(m) }
func (*CryptographicKey) ProtoMessage()               {}
func (*CryptographicKey) Descriptor() ([]byte, []int) { return fileDescriptor6, []int{3} }

type isCryptographicKey_KeyOneof interface {
	isCryptographicKey_KeyOneof()
}

type CryptographicKey_Rsa struct {
	Rsa *RSACryptographicKey `protobuf:"bytes,2,opt,name=rsa,oneof"`
}
type CryptographicKey_Dsa struct {
	Dsa *DSACryptographicKey `protobuf:"bytes,3,opt,name=dsa,oneof"`
}
type CryptographicKey_Ecc struct {
	Ecc *ECCCryptographicKey `protobuf:"bytes,4,opt,name=ecc,oneof"`
}

func (*CryptographicKey_Rsa) isCryptographicKey_KeyOneof() {}
func (*CryptographicKey_Dsa) isCryptographicKey_KeyOneof() {}
func (*CryptographicKey_Ecc) isCryptographicKey_KeyOneof() {}

func (m *CryptographicKey) GetKeyOneof() isCryptographicKey_KeyOneof {
	if m != nil {
		return m.KeyOneof
	}
	return nil
}

func (m *CryptographicKey) GetRsa() *RSACryptographicKey {
	if x, ok := m.GetKeyOneof().(*CryptographicKey_Rsa); ok {
		return x.Rsa
	}
	return nil
}

func (m *CryptographicKey) GetDsa() *DSACryptographicKey {
	if x, ok := m.GetKeyOneof().(*CryptographicKey_Dsa); ok {
		return x.Dsa
	}
	return nil
}

func (m *CryptographicKey) GetEcc() *ECCCryptographicKey {
	if x, ok := m.GetKeyOneof().(*CryptographicKey_Ecc); ok {
		return x.Ecc
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CryptographicKey) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CryptographicKey_OneofMarshaler, _CryptographicKey_OneofUnmarshaler, _CryptographicKey_OneofSizer, []interface{}{
		(*CryptographicKey_Rsa)(nil),
		(*CryptographicKey_Dsa)(nil),
		(*CryptographicKey_Ecc)(nil),
	}
}

func _CryptographicKey_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CryptographicKey)
	// key_oneof
	switch x := m.KeyOneof.(type) {
	case *CryptographicKey_Rsa:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rsa); err != nil {
			return err
		}
	case *CryptographicKey_Dsa:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Dsa); err != nil {
			return err
		}
	case *CryptographicKey_Ecc:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Ecc); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CryptographicKey.KeyOneof has unexpected type %T", x)
	}
	return nil
}

func _CryptographicKey_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CryptographicKey)
	switch tag {
	case 2: // key_oneof.rsa
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RSACryptographicKey)
		err := b.DecodeMessage(msg)
		m.KeyOneof = &CryptographicKey_Rsa{msg}
		return true, err
	case 3: // key_oneof.dsa
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DSACryptographicKey)
		err := b.DecodeMessage(msg)
		m.KeyOneof = &CryptographicKey_Dsa{msg}
		return true, err
	case 4: // key_oneof.ecc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ECCCryptographicKey)
		err := b.DecodeMessage(msg)
		m.KeyOneof = &CryptographicKey_Ecc{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CryptographicKey_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CryptographicKey)
	// key_oneof
	switch x := m.KeyOneof.(type) {
	case *CryptographicKey_Rsa:
		s := proto.Size(x.Rsa)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CryptographicKey_Dsa:
		s := proto.Size(x.Dsa)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CryptographicKey_Ecc:
		s := proto.Size(x.Ecc)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*RSACryptographicKey)(nil), "zsearch.RSACryptographicKey")
	proto.RegisterType((*DSACryptographicKey)(nil), "zsearch.DSACryptographicKey")
	proto.RegisterType((*ECCCryptographicKey)(nil), "zsearch.ECCCryptographicKey")
	proto.RegisterType((*CryptographicKey)(nil), "zsearch.CryptographicKey")
	proto.RegisterEnum("zsearch.CryptographicKey_KeyType", CryptographicKey_KeyType_name, CryptographicKey_KeyType_value)
}

func init() { proto.RegisterFile("pubkey.proto", fileDescriptor6) }

var fileDescriptor6 = []byte{
	// 390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x6c, 0x92, 0xcd, 0xcf, 0xd2, 0x40,
	0x10, 0xc6, 0x69, 0x0b, 0x14, 0x87, 0x6a, 0x9a, 0xc5, 0x98, 0x0d, 0xf1, 0xa0, 0x3d, 0x79, 0x6a,
	0x0c, 0xc6, 0xb3, 0x51, 0x68, 0x62, 0x42, 0x82, 0xc9, 0xe2, 0xc7, 0xc1, 0x83, 0xe9, 0xc7, 0x5a,
	0x08, 0xd2, 0x5d, 0x96, 0x96, 0xb4, 0xfe, 0xdf, 0xde, 0xdd, 0x8f, 0x96, 0xbc, 0x2f, 0xf4, 0xd0,
	0x64, 0x9f, 0xe9, 0xfc, 0x9e, 0xd9, 0x99, 0x1d, 0xf0, 0x78, 0x95, 0x1c, 0x68, 0x13, 0x72, 0xc1,
	0x4a, 0x86, 0xdc, 0xbf, 0x67, 0x1a, 0x8b, 0x74, 0x37, 0xf7, 0x52, 0x76, 0x3c, 0xb2, 0xc2, 0x84,
	0x83, 0x1c, 0x66, 0x64, 0xfb, 0x71, 0x29, 0x1a, 0x5e, 0xb2, 0x5c, 0xc4, 0x7c, 0xb7, 0x4f, 0xd7,
	0xb4, 0x41, 0x18, 0xdc, 0x23, 0xcb, 0xaa, 0x3f, 0xd5, 0x19, 0x5b, 0xaf, 0xac, 0x37, 0x1e, 0xe9,
	0x24, 0x9a, 0xc3, 0x84, 0xd6, 0x9c, 0x15, 0xb4, 0x28, 0xb1, 0xad, 0x7f, 0x5d, 0x35, 0xf2, 0xc0,
	0xe2, 0xd8, 0xd1, 0x41, 0x8b, 0x2b, 0x75, 0xc2, 0x43, 0xa3, 0x4e, 0xc1, 0x4f, 0x98, 0xad, 0x7a,
	0x0a, 0x69, 0xc4, 0x7a, 0x84, 0xd8, 0x2d, 0xa2, 0x54, 0xde, 0xd9, 0xe5, 0x4a, 0x35, 0x9d, 0x9d,
	0xe6, 0x6a, 0x3c, 0x32, 0xaa, 0x0e, 0x62, 0x98, 0x45, 0xcb, 0xe5, 0x9d, 0xf9, 0x73, 0x18, 0xa5,
	0x95, 0xb8, 0x50, 0x5d, 0xe0, 0x29, 0x31, 0xc2, 0xa0, 0x6d, 0x91, 0xda, 0xd8, 0x3a, 0x9d, 0xad,
	0xec, 0x9b, 0x8b, 0xfd, 0x25, 0x2e, 0x69, 0x5b, 0xaa, 0x93, 0xc1, 0x3f, 0x1b, 0xfc, 0xbb, 0x02,
	0xef, 0x61, 0x58, 0x36, 0xdc, 0xf8, 0x3f, 0x5b, 0xbc, 0x0e, 0xdb, 0x19, 0x87, 0xb7, 0x89, 0xa1,
	0xfc, 0xbe, 0xca, 0x44, 0xa2, 0xd3, 0xd1, 0x5b, 0x70, 0xc4, 0x39, 0xd6, 0x77, 0x98, 0x2e, 0x5e,
	0x5e, 0xa9, 0x9e, 0x87, 0xf8, 0x3c, 0x20, 0x2a, 0x55, 0x11, 0x99, 0x24, 0x9c, 0x1b, 0x62, 0xd5,
	0x4f, 0x64, 0x86, 0xa0, 0x69, 0xaa, 0xbb, 0x78, 0x48, 0xf4, 0x8c, 0x49, 0x11, 0x32, 0x15, 0xbd,
	0x80, 0x71, 0x22, 0xd8, 0x81, 0x16, 0x7a, 0xae, 0x13, 0xd2, 0x2a, 0x15, 0x37, 0x2b, 0x83, 0xc7,
	0x26, 0x6e, 0x94, 0x8a, 0x67, 0x34, 0xd9, 0xc7, 0x05, 0x76, 0x4d, 0xdc, 0xa8, 0xe0, 0x03, 0xb8,
	0x6d, 0xbb, 0x72, 0xb8, 0x13, 0x12, 0x6d, 0x23, 0xf2, 0x3d, 0x5a, 0xf9, 0x03, 0x34, 0x05, 0xf7,
	0xdb, 0x66, 0xbd, 0xf9, 0xf2, 0x63, 0xe3, 0x5b, 0xc8, 0x05, 0x47, 0xf6, 0xeb, 0xdb, 0xea, 0x20,
	0xdb, 0xf0, 0x1d, 0x75, 0x90, 0xb7, 0xf3, 0x87, 0x9f, 0xa6, 0xf0, 0x44, 0xee, 0xed, 0x2f, 0xb9,
	0x53, 0xec, 0x77, 0x32, 0xd6, 0x7b, 0xfa, 0xee, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc3, 0x25,
	0xb0, 0xb1, 0xce, 0x02, 0x00, 0x00,
}
